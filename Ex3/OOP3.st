Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'as yet unclassified' stamp: 'a 12/17/2018 18:31'!isKindOf: aClassOrInterface	^((super isKindOf: aClassOrInterface) or: (self class behavesLike includes: aClassOrInterface)).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'as yet unclassified' stamp: 'a 12/19/2018 18:26'!ambiguities	|methodsSet retSet interfaces|		interfaces := self behavesLike.	retSet := SortedCollection new.	interfaces do: [:interface1 | |methods1| methods1 := interface1 selectors. interface1 behavesLike do: [:interInter| methods1 := methods1 , interInter selectors].								 interfaces do:[:interface2 | interface1 ~= interface2 ifTrue:[										|methods2| 										methods2 := interface2 selectors. interface2 behavesLike do: [:interInter| methods2 := methods2 , interInter selectors].										methods1 do: [:method | ((methods2 includes: method) and:((retSet includes: method) not)) ifTrue: [retSet add: method]]										]]].			"retSet := SortedCollection new.	methodsSet := self allSelectors.	methodsSet do: [:method| |count| count := 0. (self behavesLike) do: [:Interface| (Interface selectors includes: method) ifTrue: [count:= count +1]]. count >1 ifTrue: [retSet add: method]].	self behavesLike do: [:interface1 | interface1 selectors do:[:method1 | self behavesLike do:[:interface2 | (interface1 isKindOf: interface2 class) ifFalse:[(interface2 selectors includes: method1) ifTrue:[(retSet includes: method1) ifFalse:[retSet add: (method1)]]]]]]."		^(retSet asSortedCollection: [:a :b | a < b]).		! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'a 12/10/2018 20:42'!behavesLike	^(behavesLike asSet).! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'a 12/23/2018 15:05'!compile: aSourceCode where: anOrderedCollection 	|stream codeStr line params newSourceCode|		stream := ReadStream on: aSourceCode.	line := stream nextLine , (Character cr).	params := line findTokens: #':'.	(((params size) -1) == anOrderedCollection size) ifFalse: [AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!'].	codeStr := ''.	2 to: params size do: [:i | codeStr := codeStr , (Character cr) ,  '(',(((params at: i) findTokens: #' ') at: 1),' isKindOf: ' , (anOrderedCollection at: (i-1)) , ') ifFalse: [AssertionFailure signal: ', '''', 'Type mismatch!! Argument ' , (i-1) ,' should be ', (anOrderedCollection at: (i-1)),'''].'].	"newSourceCode := line.	line := stream nextLine , (Character cr)."	newSourceCode := line,(Character cr).	line := stream nextLine.	(line notNil and: self isInterface) ifTrue: [AssertionFailure signal: 'Interfaces are not allowed to have methods that define behavior!!'].	(line notNil) ifTrue: [(ReadStream on:line) peek = $| 								ifTrue:[newSourceCode := newSourceCode, line ,(Character cr), codeStr , (Character cr). line := stream nextLine.]								ifFalse:[newSourceCode := newSourceCode, codeStr , (Character cr)].]							ifFalse:[newSourceCode := newSourceCode, codeStr , (Character cr)].	"(line notNil and: (ReadStream on:line) peek = $|) ifTrue: [newSourceCode := newSourceCode, line ,(Character cr), codeStr , (Character cr). line := stream nextLine.]									ifFalse: [newSourceCode := newSourceCode, codeStr , (Character cr)]."	"line := stream nextLine."	[line notNil] whileTrue: [newSourceCode := newSourceCode, line, (Character cr). line := stream nextLine].	self compile: newSourceCode.! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'a 12/18/2018 17:04'!isImplemented	|subClasses interMethods counter|	self isInterface ifFalse:[AssertionFailure signal: (self asString,' is not an interface!!')].	subClasses := MyObject allSubclasses.	interMethods := self selectors.	self behavesLike do:[:interface | interMethods := interMethods , interface selectors].	counter := 0.	subClasses do: [:subC | counter := 0. subC isInterface ifFalse:[((subC behavesLike) includes: self) ifTrue: [				interMethods size == 0 ifTrue:[^true].				interMethods do:[:method| (subC allSelectors includes: method) ifTrue:[counter := counter+1]. counter == interMethods size ifTrue:[^true]]]]].	^false.! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'a 12/10/2018 20:40'!isInterface	^isInterface.! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'a 12/17/2018 18:39'!new	|methods|	(self isInterface) ifTrue: [AssertionFailure signal: 'Interfaces can not be instantiated!!'].	methods := self allSelectors.	behavesLike do: [:interface | interface allSelectors do: [:interMethod | (methods includes: interMethod) ifFalse: [AssertionFailure signal: 'Can not instantiate an Abstract class!!']] ].	^(super new).! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'a 12/15/2018 20:09'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	|newClass|	newClass := super subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName.	newClass instVarNamed: 'isInterface' put: false.	newClass instVarNamed: 'behavesLike' put: self behavesLike.	^newClass.! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'a 12/15/2018 23:15'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	|newClass tmp|	isInterface ifTrue:[(self == MyObject) ifFalse:[AssertionFailure signal: 'Interfaces must derive from MyObject!!']].	isInterface ifTrue:[(instVarNames isEmpty) ifFalse:[AssertionFailure signal: 'Interfaces can not have state!!']].	isInterface ifFalse:[(self isInterface) ifTrue:[AssertionFailure signal: 'Classes can not derive from an interface!!']].	aCollection do: [:x | x isInterface ifFalse:[AssertionFailure signal: 'Can not behave like a non-interface!!']].	newClass := self subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName.	newClass instVarNamed: 'isInterface' put: isInterface.	tmp := self behavesLike asCollection.	aCollection do: [:x | tmp := tmp, x behavesLike].	isInterface ifTrue: [tmp add: newClass].	newClass instVarNamed: 'behavesLike' put: tmp.	^newClass.! !