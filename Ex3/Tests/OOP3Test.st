TestCase subclass: #BaseTest	instanceVariableNames: 'category'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3Test'!!BaseTest methodsFor: 'initialize-release' stamp: 'tg 12/10/2018 10:29'!setUp	BaseTest deleteClasses: {I . I1 . I2 . I3 . I4 .C . C1 . C2 . C3}.	MyObject instVarNamed: 'isInterface' put: false.	MyObject instVarNamed: 'behavesLike' put: {}.	category := 'OOP3'.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/10/2018 10:20'!newClassWithName: name	self newClassWithName: name instanceVariableNames: '' behavesLike: {}.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/9/2018 21:49'!newClassWithName: name behavesLike: behavesLike	self newClassWithName: name instanceVariableNames: '' behavesLike: behavesLike.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/9/2018 21:55'!newClassWithName: name behavesLike: behavesLike superClass: superClass	self newClassWithName: name instanceVariableNames: '' behavesLike: behavesLike superClass: superClass.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/10/2018 10:21'!newClassWithName: name instanceVariableNames: vars	self newClassWithName: name instanceVariableNames: vars behavesLike: {}.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/9/2018 21:54'!newClassWithName: name instanceVariableNames: vars behavesLike: behavesLike	self newClassWithName: name instanceVariableNames: vars behavesLike: behavesLike superClass: MyObject.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/10/2018 13:17'!newClassWithName: name instanceVariableNames: vars behavesLike: behavesLike superClass: superClass	self newClassWithName: name instanceVariableNames: vars classVariableNames: '' behavesLike: behavesLike superClass: superClass.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/10/2018 17:45'!newClassWithName: name instanceVariableNames: vars classVariableNames: classVars	self newClassWithName: name instanceVariableNames: vars classVariableNames: classVars behavesLike: {} superClass: MyObject.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/10/2018 13:17'!newClassWithName: name instanceVariableNames: vars classVariableNames: classVars behavesLike: behavesLike	self newClassWithName: name instanceVariableNames: vars classVariableNames: classVars behavesLike: behavesLike superClass: MyObject.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/10/2018 13:17'!newClassWithName: name instanceVariableNames: vars classVariableNames: classVars behavesLike: behavesLike superClass: superClass	superClass subclass: name		isInterface: false behavesLike: behavesLike		instanceVariableNames: vars classVariableNames: classVars		poolDictionaries: '' category: category.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/10/2018 10:21'!newClassWithName: name superClass: superClass	self newClassWithName: name instanceVariableNames: '' behavesLike: {} superClass: superClass.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/10/2018 10:21'!newInterfaceWithName: name	self newInterfaceWithName: name behavesLike: {}.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/9/2018 21:14'!newInterfaceWithName: name behavesLike: behavesLike	self newInterfaceWithName: name instanceVariableNames: '' behavesLike: behavesLike.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/9/2018 21:17'!newInterfaceWithName: name instanceVariableNames: vars behavesLike: behavesLike	self newInterfaceWithName: name instanceVariableNames: vars behavesLike: behavesLike superClass: MyObject.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/9/2018 21:17'!newInterfaceWithName: name instanceVariableNames: vars behavesLike: behavesLike superClass: class	class subclass: name		isInterface: true behavesLike: behavesLike		instanceVariableNames: vars classVariableNames: ''		poolDictionaries: '' category: category.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/10/2018 17:31'!newSimpleClassWithName: name	self newSimpleClassWithName: name superClass: MyObject.! !!BaseTest methodsFor: 'utilsSubclass' stamp: 'tg 12/10/2018 17:31'!newSimpleClassWithName: name superClass: superClass	superClass subclass: name		instanceVariableNames: '' classVariableNames: ''		poolDictionaries: '' category: category.! !!BaseTest methodsFor: 'utils' stamp: 'tg 12/10/2018 20:52'!collection: aCollection1 equalsWith: aCollection2	^ (aCollection1 includesAllOf: aCollection2) and: [aCollection1 size = aCollection2 size].! !!BaseTest methodsFor: 'utils' stamp: 'tg 12/8/2018 14:23'!getExceptionMessage: exceptionNumber	^ self getExceptionMessage: exceptionNumber withNumber: '' andClass: ''.! !!BaseTest methodsFor: 'utils' stamp: 'tg 12/8/2018 14:23'!getExceptionMessage: exceptionNumber withClass: class	^ self getExceptionMessage: exceptionNumber withNumber: '' andClass: class.! !!BaseTest methodsFor: 'utils' stamp: 'tg 12/9/2018 14:58'!getExceptionMessage: exceptionNumber withNumber: number andClass: class	(exceptionNumber = 1.1) ifTrue: [		^ 'Can not compile method, number of arguments is not equal to the number of constraints!!'.	] ifFalse: [ (exceptionNumber = 1.2) ifTrue: [		^ 'Type mismatch!! Argument ' , number, ' should be ', class.	] ifFalse: [ (exceptionNumber = 2.1) ifTrue: [		^ 'Interfaces must derive from MyObject!!'.	] ifFalse: [ (exceptionNumber = 2.2) ifTrue: [		^ 'Interfaces can not have state!!'.	] ifFalse: [ (exceptionNumber = 2.3) ifTrue: [		^ 'Classes can not derive from an interface!!'	] ifFalse: [ (exceptionNumber = 2.4) ifTrue: [		^ 'Can not behave like a non-interface!!'.	] ifFalse: [ (exceptionNumber = 2.5) ifTrue: [		^ class, ' is not an interface!!'.	] ifFalse: [ (exceptionNumber = 2.6) ifTrue: [		^ 'Interfaces can not be instantiated!!'.	] ifFalse: [ (exceptionNumber = 2.7) ifTrue: [		^ 'Interfaces are not allowed to have methods that define behavior!!'.	] ifFalse: [ (exceptionNumber = 3.1) ifTrue: [		^ 'Can not instantiate an Abstract class!!'.	] ifFalse: [		^ ''.	]]]]]]]]]].! !!BaseTest methodsFor: 'utils' stamp: 'tg 12/10/2018 22:28'!sortedCollection: aCollection1 equalsWith: aCollection2	(aCollection1 size = aCollection2 size) ifFalse: [		^ false.	].		aCollection1 doWithIndex: [:object :index |		(object = (aCollection2 at: index)) ifFalse: [			^ false.		].	].	^true.! !!BaseTest methodsFor: 'testing' stamp: 'tg 12/9/2018 22:22'!assertBlock: assertBlock finally: finallyBlock	assertBlock on: AssertionFailure do: [		finallyBlock value.		self assert: false.	].	finallyBlock value.! !!BaseTest methodsFor: 'testing' stamp: 'tg 12/9/2018 21:24'!testException: blockToTest withExceptionNumber: exceptionNumber	self testException: blockToTest withExceptionNumber: exceptionNumber andClass: '' finally: [].! !!BaseTest methodsFor: 'testing' stamp: 'tg 12/9/2018 22:59'!testException: blockToTest withExceptionNumber: exceptionNumber andClass: class	self testException: blockToTest withExceptionNumber: exceptionNumber andNumber: '' andClass: class finally: [].! !!BaseTest methodsFor: 'testing' stamp: 'tg 12/9/2018 21:21'!testException: blockToTest withExceptionNumber: exceptionNumber andClass: class finally: finallyBlock		self testException: blockToTest withExceptionNumber: exceptionNumber andNumber: '' andClass: class finally: finallyBlock.! !!BaseTest methodsFor: 'testing' stamp: 'tg 12/10/2018 11:24'!testException: blockToTest withExceptionNumber: exceptionNumber andNumber: number andClass: class finally: finallyBlock		self testException: blockToTest withExceptionNumber: exceptionNumber andNumber: number andClass: class finally: finallyBlock		finallyOnFail: [].! !!BaseTest methodsFor: 'testing' stamp: 'tg 12/10/2018 17:56'!testException: blockToTest withExceptionNumber: exceptionNumber andNumber: number andClass: class finally: finallyBlockfinallyOnFail: finallyOnFailBlock	blockToTest on: AssertionFailure do: [:e |		finallyBlock value.		[self assert: (e messageText) = (self getExceptionMessage: exceptionNumber withNumber: number andClass: class).]				on: AssertionFailure do: [					finallyOnFailBlock value.					self assert: false.				].		^0.	].	finallyBlock value.	finallyOnFailBlock value.	self assert: false.! !!BaseTest methodsFor: 'testing' stamp: 'tg 12/10/2018 11:26'!testException: blockToTest withExceptionNumber: exceptionNumber andNumber: number andClass: class finallyOnFail: finallyOnFailBlock		self testException: blockToTest withExceptionNumber: exceptionNumber andNumber: number andClass: class finally: []		finallyOnFail: finallyOnFailBlock.! !!BaseTest methodsFor: 'testing' stamp: 'tg 12/9/2018 14:57'!testException: blockToTest withExceptionNumber: exceptionNumber finally: finallyBlock		self testException: blockToTest withExceptionNumber: exceptionNumber andNumber: '' andClass: '' finally: finallyBlock.! !!BaseTest methodsFor: 'testing' stamp: 'tg 12/10/2018 11:27'!testException: blockToTest withExceptionNumber: exceptionNumber finallyOnFail: finallyOnFailBlock	self testException: blockToTest withExceptionNumber: exceptionNumber andNumber: '' andClass: '' finallyOnFail: finallyOnFailBlock.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BaseTest class	instanceVariableNames: ''!!BaseTest class methodsFor: 'utils' stamp: 'tg 12/9/2018 21:28'!deleteClass: class	(Smalltalk hasClassNamed: class) ifTrue: [		Smalltalk removeClassNamed: class	].! !!BaseTest class methodsFor: 'utils' stamp: 'tg 12/9/2018 21:31'!deleteClasses: classes	classes do: [:class |		(Smalltalk hasClassNamed: class) ifTrue: [		Smalltalk removeClassNamed: class		].	].! !!BaseTest class methodsFor: 'utils' stamp: 'tg 12/11/2018 12:16'!deleteMethod: methodName ofClass: class	(class methodDictionary values select: [:method | 		('', (method selector)) = methodName.	]) do: [:method |		class removeSelector: method selector.	].! !BaseTest subclass: #MyObjectTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3Test'!!MyObjectTest methodsFor: 'isInterface' stamp: 'tg 12/10/2018 12:30'!testIsInterface_success_isInterface	self newInterfaceWithName: #I.	self assertBlock: [		self assert: (I isInterface).	] finally: [		BaseTest deleteClass: #I.	].! !!MyObjectTest methodsFor: 'isInterface' stamp: 'tg 12/10/2018 18:30'!testIsInterface_success_isNotInterface	self newClassWithName: #C.	self assertBlock: [		self assert: ((C isInterface) = false).	] finally: [		BaseTest deleteClass: #C.	].! !!MyObjectTest methodsFor: 'behavesLike' stamp: 'tg 12/10/2018 17:20'!testBehavesLike_success_empty	self newClassWithName: #C.	self assertBlock: [		self assert: (self collection: (C behavesLike) equalsWith: {}).	] finally: [		BaseTest deleteClass: C.	].! !!MyObjectTest methodsFor: 'behavesLike' stamp: 'tg 12/10/2018 17:20'!testBehavesLike_success_notEmpty	self newInterfaceWithName: #I1.	self newInterfaceWithName: #I2.	self newClassWithName: #C behavesLike: {I1 . I2}.	self assertBlock: [		self assert: (self collection: (C behavesLike) equalsWith: {I1 . I2}).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #C}.	].! !!MyObjectTest methodsFor: 'behavesLike' stamp: 'tg 12/10/2018 17:19'!testBehavesLike_success_recursiveClass	self newInterfaceWithName: #I.	self newClassWithName: #C1 behavesLike: {I}.	self newClassWithName: #C2 superClass: C1.	self newClassWithName: #C3 superClass: C2.	self assertBlock: [		self assert: (self collection: (C3 behavesLike) equalsWith: {I}).	] finally: [		BaseTest deleteClasses: {#I . #C1 . #C2 . #C3}.	].! !!MyObjectTest methodsFor: 'behavesLike' stamp: 'tg 12/10/2018 17:19'!testBehavesLike_success_recursiveInterface	self newInterfaceWithName: #I1.	self newInterfaceWithName: #I2 behavesLike: {I1}.	self newInterfaceWithName: #I3 behavesLike: {I2}.	self newInterfaceWithName: #I4 behavesLike: {I3}.	self assertBlock: [		self assert: (self collection: (I4 behavesLike) equalsWith: {I1 . I2 . I3 . I4}).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #I3 . #I4}.	].! !!MyObjectTest methodsFor: 'isImplemented' stamp: 'tg 12/10/2018 17:18'!testIsImplemented_fromImplementedToNotImplemented	self newInterfaceWithName: #I.	I compile: 'm1' where: #().	I compile: 'm2' where: #().		self newClassWithName: #C1 behavesLike: {I}.	C1 compile:		'm1			^1'	where: #().		self newClassWithName: #C2 superClass: C1.		self newClassWithName: #C3 superClass: C2.	C3 compile:		'm2			^2'	where: #().		self assertBlock: [		self assert: (I isImplemented).		I compile: 'm3' where: #().		self assert: ((I isImplemented) = false).	] finally: [		BaseTest deleteClasses: {#I . #C1 . #C2 . #C3}.	].! !!MyObjectTest methodsFor: 'isImplemented' stamp: 'tg 12/10/2018 17:17'!testIsImplemented_fromNotImplementedToImplemented	self newInterfaceWithName: #I.	I compile: 'm1' where: #().	I compile: 'm2' where: #().		self newClassWithName: #C1 behavesLike: {I}.	C1 compile:		'm1			^1'	where: #().		self newClassWithName: #C2 superClass: C1.		self newClassWithName: #C3 superClass: C2.		self assertBlock: [		self assert: ((I isImplemented) = false).				C3 compile:		'm2			^2'		where: #().				self assert: (I isImplemented).	] finally: [		BaseTest deleteClasses: {#I . #C1 . #C2 . #C3}.	].! !!MyObjectTest methodsFor: 'isImplemented' stamp: 'tg 12/10/2018 20:48'!testIsImplemented_implemented_parentInterfaceHasMethods	self newInterfaceWithName: #I1.	I1 compile: 'm1' where: #().	self newInterfaceWithName: #I2 behavesLike: {I1}.		self newClassWithName: #C behavesLike: {I2}.	C compile: 		'm1			^1.'	where: #().		self assertBlock: [		self assert: (I2 isImplemented).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #C}.	].! !!MyObjectTest methodsFor: 'isImplemented' stamp: 'tg 12/10/2018 20:06'!testIsImplemented_notAnInterface	self testException: [		MyObject isImplemented.	] withExceptionNumber: 2.5	andClass: 'MyObject'.! !!MyObjectTest methodsFor: 'isImplemented' stamp: 'tg 12/10/2018 17:17'!testIsImplemented_notImplemented	self newInterfaceWithName: #I.	I compile: 'm1' where: #().		self assertBlock: [		self assert: ((I isImplemented) = false).	] finally: [		BaseTest deleteClass: #I.	].! !!MyObjectTest methodsFor: 'isImplemented' stamp: 'tg 12/10/2018 19:32'!testIsImplemented_notImplemented2	self newInterfaceWithName: #I.		self assertBlock: [		self assert: ((I isImplemented) = false).	] finally: [		BaseTest deleteClass: #I.	].! !!MyObjectTest methodsFor: 'isImplemented' stamp: 'tg 12/10/2018 20:48'!testIsImplemented_notImplemented_parentInterfaceHasMethods	self newInterfaceWithName: #I1.	I1 compile: 'm1' where: #().	self newInterfaceWithName: #I2 behavesLike: {I1}.		self newClassWithName: #C behavesLike: {I2}.		self assertBlock: [		self assert: ((I2 isImplemented) = false).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #C}.	].! !!MyObjectTest methodsFor: 'isImplemented' stamp: 'tg 12/10/2018 17:16'!testIsImplemented_recursiveInspection	self newInterfaceWithName: #I.	I compile: 'm1' where: #().	I compile: 'm2' where: #().		self newClassWithName: #C1 behavesLike: {I}.	C1 compile:		'm1			^1'	where: #().		self newClassWithName: #C2 superClass: C1.		self newClassWithName: #C3 superClass: C2.	C3 compile:		'm2			^2'	where: #().		self assertBlock: [		self assert: (I isImplemented).	] finally: [		BaseTest deleteClasses: {#I . #C1 . #C2 . #C3}.	].! !!MyObjectTest methodsFor: 'ambiguities' stamp: 'tg 12/10/2018 20:56'!testAmbiguities_empty	self assert: (self sortedCollection: (MyObject ambiguities) equalsWith: #()).! !!MyObjectTest methodsFor: 'ambiguities' stamp: 'tg 12/11/2018 12:45'!testAmbiguities_fromNoAmbiguitiesToAmbiguities	self newInterfaceWithName: #I1.	I1 compile: 'm2'.		self newInterfaceWithName: #I2.	I2 compile: 'm2'.		self newInterfaceWithName: #I3.	I3 compile: 'm1'.		self newClassWithName: #C behavesLike: {I1 . I2 . I3}.		self assertBlock: [		self assert: (self sortedCollection: (C ambiguities) equalsWith: #(m2)).		I2 compile: 'm1'.		self assert: (self sortedCollection: (C ambiguities) equalsWith: #(m1 m2)).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #I3 . #C}.	].! !!MyObjectTest methodsFor: 'ambiguities' stamp: 'tg 12/11/2018 12:47'!testAmbiguities_hasAmbiguities	self newInterfaceWithName: #I1.	I1 compile: 'm2'.		self newInterfaceWithName: #I2.	I2 compile: 'm1'.	I2 compile: 'm2'.		self newInterfaceWithName: #I3.	I3 compile: 'm1'.		self newClassWithName: #C behavesLike: {I1 . I2 . I3}.		self assertBlock: [		self assert: (self sortedCollection: (C ambiguities) equalsWith: #(m1 m2)).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #I3 . #C}.	].! !!MyObjectTest methodsFor: 'ambiguities' stamp: 'tg 12/11/2018 15:13'!testAmbiguities_hasAmbiguitiesWithInheritance	self newInterfaceWithName: #I1.	I1 compile: 'm1'.		self newInterfaceWithName: #I2 behavesLike: {I1}.	I2 compile: 'm2'.		self newInterfaceWithName: #I3 behavesLike: {I1}.	I3 compile: 'm3'.		self newClassWithName: #C1 behavesLike: {I2 . I3}.	self newClassWithName: #C2 superClass: C1.		self assertBlock: [		self assert: (self sortedCollection: (C1 ambiguities) equalsWith: #(m1)).		self assert: (self sortedCollection: (C2 ambiguities) equalsWith: #(m1)).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #I3 . #C1 . #C2}.	].! !!MyObjectTest methodsFor: 'ambiguities' stamp: 'tg 12/11/2018 13:00'!testAmbiguities_hasAmbiguities_faqEx2	self newInterfaceWithName: #I1.	I1 compile: 'm'.		self newInterfaceWithName: #I2 behavesLike: {I1}.		self newClassWithName: #C behavesLike: {I2}.		self assertBlock: [		self assert: (self sortedCollection: (I1 ambiguities) equalsWith: #()).		self assert: (self sortedCollection: (I2 ambiguities) equalsWith: #(m)).		self assert: (self sortedCollection: (C ambiguities) equalsWith: #(m)).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #C}.	].! !!MyObjectTest methodsFor: 'ambiguities' stamp: 'tg 12/11/2018 13:03'!testAmbiguities_hasAmbiguities_faqEx3	self newInterfaceWithName: #I1.	I1 compile: 'm'.		self newInterfaceWithName: #I2 behavesLike: {I1}.		self newInterfaceWithName: #I3 behavesLike: {I1}.		self newClassWithName: #C behavesLike: {I1}.		self assertBlock: [		self assert: (self sortedCollection: (I1 ambiguities) equalsWith: #()).		self assert: (self sortedCollection: (I2 ambiguities) equalsWith: #(m)).		self assert: (self sortedCollection: (I3 ambiguities) equalsWith: #(m)).		self assert: (self sortedCollection: (C ambiguities) equalsWith: #()).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #I3 . #C}.	].! !!MyObjectTest methodsFor: 'ambiguities' stamp: 'tg 12/11/2018 15:12'!testAmbiguities_noAmbiguities	self newInterfaceWithName: #I1.	I1 compile: 'm1'.		self newInterfaceWithName: #I2.	I2 compile: 'm2'.		self newInterfaceWithName: #I3.	I3 compile: 'm3'.		self newClassWithName: #C1 behavesLike: {I1 . I2 . I3}.	self newClassWithName: #C2 superClass: C1.		self assertBlock: [		self assert: (self sortedCollection: (C1 ambiguities) equalsWith: #()).		self assert: (self sortedCollection: (C2 ambiguities) equalsWith: #()).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #I3 . #C1 . #C2}.	].! !!MyObjectTest methodsFor: '27noNewInterfaceInstance' stamp: 'tg 12/10/2018 17:23'!testNoNewInterfaceInstance_throwException	self newInterfaceWithName: #I.	self testException: [		I new.	] withExceptionNumber: 2.6	finally: [		BaseTest deleteClass: #I.	].! !!MyObjectTest methodsFor: '28interfaceMethodWithoutImplementation' stamp: 'tg 12/10/2018 17:23'!testInterfaceMethodWithoutImplementation	self newInterfaceWithName: #I.	self testException: [		I compile:			'm1				^1'		where: #().	] withExceptionNumber: 2.7	finally: [		BaseTest deleteClass: #I.	].! !!MyObjectTest methodsFor: '31noNewAbstractInstance' stamp: 'tg 12/10/2018 17:23'!testNoNewAbstractInstance	self newInterfaceWithName: #I.	I compile: 'm' where: #().	self newClassWithName: #C behavesLike: {I}.	self testException: [		C new.	] withExceptionNumber: 3.1	finally: [		BaseTest deleteClasses: {#I . #C}.	].! !!MyObjectTest methodsFor: '31noNewAbstractInstance' stamp: 'tg 12/11/2018 00:06'!testNoNewAbstractInstance_fromAbstractToNoAbstract	self newInterfaceWithName: #I.	I compile: 'm' where: #().		self newClassWithName: #C1.	self newClassWithName: #C2 superClass: C1.	self newClassWithName: #C3 behavesLike: {I} superClass: C2.		self testException: [		C3 new.	] withExceptionNumber: 3.1	finallyOnFail: [		BaseTest deleteClasses: {#I . #C1 . #C2 . #C3}.	].	C1 compile: 		'm			^1.'	where: #().		C3 new.		BaseTest deleteClasses: {#I . #C1 . #C2 . #C3}.! !!MyObjectTest methodsFor: '31noNewAbstractInstance' stamp: 'tg 12/11/2018 00:44'!testNoNewAbstractInstance_fromNoAbstractToAbstract	self newInterfaceWithName: #I.	self newClassWithName: #C behavesLike: {I}.		C new.		I compile: 'm' where: #().	self testException: [		C new.	] withExceptionNumber: 3.1	finally: [		BaseTest deleteClasses: {#I . #C}.	].! !!MyObjectTest methodsFor: 'isKindOf' stamp: 'tg 12/11/2018 00:53'!testIsKindOf_canConstrainMethod	self newInterfaceWithName: #I1.	self newInterfaceWithName: #I2 behavesLike: {I1}.	self newClassWithName: #C1 behavesLike: {I2}.	self newClassWithName: #C2 superClass: C1.		C2 compile: 		'm: arg			^2'	where: #(I1).		self assertBlock: [		self assert: ((C2 new m: (C2 new)) = 2).	] finally: [		BaseTest deleteClasses: #(#I1 . #I2 . #C1 . #C2).	].! !!MyObjectTest methodsFor: 'isKindOf' stamp: 'tg 12/10/2018 11:33'!testIsKindOf_integer	self assert: (1 isKindOf: Integer).! !!MyObjectTest methodsFor: 'isKindOf' stamp: 'tg 12/10/2018 17:16'!testIsKindOf_interface	self newInterfaceWithName: #I1.	self newInterfaceWithName: #I2 behavesLike: {I1}.	self newClassWithName: #C1 behavesLike: {I2}.	self newClassWithName: #C2 superClass: C1.		self assertBlock: [		self assert: ((C2 new) isKindOf: I1).	] finally: [		BaseTest deleteClasses: #(#I1 . #I2 . #C1 . #C2).	].! !!MyObjectTest methodsFor: 'isKindOf' stamp: 'tg 12/10/2018 11:33'!testIsKindOf_number	self assert: (1 isKindOf: Number).! !!MyObjectTest methodsFor: 'subclass' stamp: 'tg 12/10/2018 17:15'!testSubclass_fail24_class	self testException: [		self newClassWithName: #C behavesLike: {MyObject}.	] withExceptionNumber: 2.4	finally: [		BaseTest deleteClass: {#C}.	].! !!MyObjectTest methodsFor: 'subclass' stamp: 'tg 12/10/2018 17:15'!testSubclass_fail24_interface	self testException: [		self newInterfaceWithName: #I behavesLike: {MyObject}.	] withExceptionNumber: 2.4	finally: [		BaseTest deleteClass: {#I}.	].! !!MyObjectTest methodsFor: 'subclass' stamp: 'tg 12/10/2018 17:15'!testSubclass_failByOrder21	self newInterfaceWithName: #I1.	self testException: [		self newInterfaceWithName: #I2 instanceVariableNames: 'var' behavesLike: {MyObject} superClass: I1.	] withExceptionNumber: 2.1	finally: [		BaseTest deleteClasses: {#I1 . #I2}.	].! !!MyObjectTest methodsFor: 'subclass' stamp: 'tg 12/10/2018 17:15'!testSubclass_failByOrder22	self testException: [		self newInterfaceWithName: #I instanceVariableNames: 'var' behavesLike: {MyObject}.	] withExceptionNumber: 2.2	finally: [		BaseTest deleteClass: {#I}.	].! !!MyObjectTest methodsFor: 'subclass' stamp: 'tg 12/10/2018 17:14'!testSubclass_failByOrder23	self newInterfaceWithName: #I.	self testException: [		self newClassWithName: #C behavesLike: {MyObject} superClass: I.	] withExceptionNumber: 2.3	finally: [		BaseTest deleteClasses: {#I . #C}.	].! !!MyObjectTest methodsFor: 'subclass' stamp: 'tg 12/10/2018 17:32'!testSubclass_simpleClassEmptyBehavesLike	self newSimpleClassWithName: #C.	self assertBlock: [		self assert: ((C isInterface) = false).		self assert: (self collection: (C behavesLike) equalsWith: {}).	] finally: [		BaseTest deleteClass: #C.	].! !!MyObjectTest methodsFor: 'subclass' stamp: 'tg 12/10/2018 17:34'!testSubclass_simpleClassNotEmptyBehavesLike	self newInterfaceWithName: #I.	self newClassWithName: #C1 behavesLike: {I}.	self newSimpleClassWithName: #C2 superClass: C1.	self assertBlock: [		self assert: ((C2 isInterface) = false).		self assert: (self collection: (C2 behavesLike) equalsWith: {I}).	] finally: [		BaseTest deleteClasses: {#I . #C1 . #C2}.	].! !!MyObjectTest methodsFor: 'subclass' stamp: 'tg 12/10/2018 17:35'!testSubclass_success_classes	self newInterfaceWithName: #I1.	self newInterfaceWithName: #I2 behavesLike: {I1}.	self newInterfaceWithName: #I3.		self newClassWithName: #C1 behavesLike: {I2 . I3}.	self newClassWithName: #C2 behavesLike: {I3} superClass: C1.		self assertBlock: [			self assert: (C1 isInterface = false).		self assert: (self collection: (C1 behavesLike) equalsWith: {I1 . I2 . I3}).		self assert: (C2 isInterface = false).		self assert: (self collection: (C2 behavesLike) equalsWith: {I1 . I2 . I3}).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #I3 . #C1 . #C2}.	].! !!MyObjectTest methodsFor: 'subclass' stamp: 'tg 12/10/2018 17:09'!testSubclass_success_interfaces	self newInterfaceWithName: #I1.	self newInterfaceWithName: #I2 behavesLike: {I1}.	self newInterfaceWithName: #I3 behavesLike: {I1 . I2}.	self newInterfaceWithName: #I4 behavesLike: {I3}.		self assertBlock: [				self assert: (I1 isInterface).		self assert: (self collection: (I1 behavesLike) equalsWith: {I1}).			self assert: (I2 isInterface).		self assert: (self collection: (I2 behavesLike) equalsWith: {I1 . I2}).			self assert: (I3 isInterface).		self assert: (self collection: (I3 behavesLike) equalsWith: {I1 . I2 . I3}).		self assert: (I4 isInterface).		self assert: (self collection: (I4 behavesLike) equalsWith: {I1 . I2 . I3 . I4}).	] finally: [		BaseTest deleteClasses: {#I1 . #I2 . #I3 . #I4}.	].! !!MyObjectTest methodsFor: 'compileWhere' stamp: 'tg 12/11/2018 00:42'!testCompileWhere_moreArgumentsThenConstraints	self newClassWithName: #C.	self testException: [		C compile:			'methodWith: argument1 and: argument2.'		where: #(nil).	] withExceptionNumber: 1.1	finally: [		BaseTest deleteClass: #C.	].! !!MyObjectTest methodsFor: 'compileWhere' stamp: 'tg 12/11/2018 00:42'!testCompileWhere_moreConstraintsThenArguments	self newClassWithName: #C.	self testException: [		C compile:			'methodWith: argument'		where: #(nil, Integer).	] withExceptionNumber: 1.1	finally: [		BaseTest deleteClass: #C.	].	! !!MyObjectTest methodsFor: 'compileWhere' stamp: 'tg 12/11/2018 00:42'!testCompileWhere_success	self newClassWithName: #C.	C compile:		'methodWith: argument1 and: argument2 and: argument3 			^ argument2 * argument3.'	where: #(String Float Integer).		self assertBlock: [		self assert: ((C new methodWith: 'string' and: 2.0 and: 3) = 6.0).	] finally: [		BaseTest deleteClass: #C.	].! !!MyObjectTest methodsFor: 'compileWhere' stamp: 'tg 12/11/2018 00:42'!testCompileWhere_typeMismatch	self newClassWithName: #C.	C compile:		'methodWith: argument1 and: argument2 and: argument3'	where: #(String Float Integer).		self testException: [		C new methodWith: 'string1' and: 'string2' and: 'string3'.	] withExceptionNumber: 1.2 andNumber: '2' andClass: 'Float'	finally: [		BaseTest deleteClass: #C.	].! !