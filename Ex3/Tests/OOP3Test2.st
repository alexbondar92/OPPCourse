TestCase subclass: #MyObjectTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3Test'!!MyObjectTest methodsFor: 'as yet unclassified' stamp: 'Y.B.Z 12/19/2018 13:43'!testMyObject	| flag a |	MyObject instVarNamed: 'isInterface' put: false.	MyObject instVarNamed: 'behavesLike' put: {}.	(Smalltalk hasClassNamed: #A) ifTrue: [Smalltalk removeClassNamed: #A].	(Smalltalk hasClassNamed: #B) ifTrue: [Smalltalk removeClassNamed: #B].	(Smalltalk hasClassNamed: #C) ifTrue: [Smalltalk removeClassNamed: #C].	(Smalltalk hasClassNamed: #IA) ifTrue: [Smalltalk removeClassNamed: #IA].	(Smalltalk hasClassNamed: #IB) ifTrue: [Smalltalk removeClassNamed: #IB].	(Smalltalk hasClassNamed: #D) ifTrue: [Smalltalk removeClassNamed: #D].	(Smalltalk hasClassNamed: #SA) ifTrue: [Smalltalk removeClassNamed: #SA].	(Smalltalk hasClassNamed: #SB) ifTrue: [Smalltalk removeClassNamed: #SB].	(Smalltalk hasClassNamed: #SC) ifTrue: [Smalltalk removeClassNamed: #SC].	(Smalltalk hasClassNamed: #IAA) ifTrue: [Smalltalk removeClassNamed: #IAA].	(Smalltalk hasClassNamed: #IBB) ifTrue: [Smalltalk removeClassNamed: #IBB].	(Smalltalk hasClassNamed: #ICC) ifTrue: [Smalltalk removeClassNamed: #ICC].	(Smalltalk hasClassNamed: #Abs) ifTrue: [Smalltalk removeClassNamed: #Abs].	(Smalltalk hasClassNamed: #NonAbs) ifTrue: [Smalltalk removeClassNamed: #NonAbs].	(Smalltalk hasClassNamed: #NonAbsEmpty) ifTrue: [Smalltalk removeClassNamed: #NonAbsEmpty].	(Smalltalk hasClassNamed: #NonAbsToBeAbs) ifTrue: [Smalltalk removeClassNamed: #NonAbsToBeAbs].	(Smalltalk hasClassNamed: #IDD) ifTrue: [Smalltalk removeClassNamed: #IDD].	(Smalltalk hasClassNamed: #E) ifTrue: [Smalltalk removeClassNamed: #E].	(Smalltalk hasClassNamed: #IEE) ifTrue: [Smalltalk removeClassNamed: #IEE].	(Smalltalk hasClassNamed: #NonAbsTwo) ifTrue: [Smalltalk removeClassNamed: #NonAbsTwo].	(Smalltalk hasClassNamed: #NonAbsInheritance) ifTrue: [Smalltalk removeClassNamed: #NonAbsInheritance].	MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	MyObject subclass: #B instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	a := MyObject subclass: #C isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	self assert: (a = C).	a := MyObject subclass: #IA isInterface: true behavesLike: { C } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	self assert: (a = IA).	a := MyObject subclass: #IB isInterface: true behavesLike: { IA } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	self assert: (a = IB).	a := MyObject subclass: #D isInterface: false behavesLike: { IB } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	self assert: (a = D).	a := MyObject subclass: #E isInterface: false behavesLike: { IA } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	self assert: (a = E).	A subclass: #SA instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	B subclass: #SB instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.		self assert: (A isInterface = false).	self assert: (B isInterface = false).	self assert: (C isInterface = true).	self assert: (IA isInterface = true).	self assert: (IB isInterface = true).	self assert: (D isInterface = false).		self assert: (IA behavesLike size = 2).	self assert: (A behavesLike size = 0).	self assert: (D behavesLike size = 3).	self assert: (IB behavesLike size = 3).	self assert: (C behavesLike size = 1).		flag := false.	[A isImplemented] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'A is not an interface!!')	].	self assert: (flag = true).		"C compile: 'defaultFoo'."		C compile: 'foo1'.	C compile: 'foo2'.	self assert: (C isImplemented = false).	D compile: 'foo1'.	E compile: 'foo2'.	self assert: (C isImplemented = false).	D compile: 'foo2	^2'.	self assert: (C isImplemented = true).		self assert: (IB ambiguities size = 0).	"IA compile: 'defaultFoo: a	^a'."		self assert: (IB ambiguities size = 0).	IA compile: 'foo1'.	self assert: (IB ambiguities size = 1).	IB compile: 'foo1'.	self assert: (IB ambiguities size = 1).		"IB compile: 'defaultFoo'."		a := IB ambiguities.	self assert: (a size = 1).		"self assert: ((a at: 1) = #defaultFoo)."		self assert: ((a at: 1) = #foo1).	IB compile: 'foo2'.	a := IB ambiguities.	self assert: (a size = 2).		"self assert: ((a at: 1) = #defaultFoo)."		self assert: ((a at: 1) = #foo1).	self assert: ((a at: 2) = #foo2).		flag := false.	[IA new] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'Interfaces can not be instantiated!!')	].	self assert: (flag = true).		flag := false.	[IB compile: 'foo	^3'] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'Interfaces are not allowed to have methods that define behavior!!')	].	self assert: (flag = true).		flag := false.	[C subclass: #SC isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'Classes can not derive from an interface!!')	].	self assert: (flag = true).		flag := false.	[A subclass: #IB isInterface: true behavesLike: { IA } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'Interfaces must derive from MyObject!!')	].	self assert: (flag = true).		flag := false.	[MyObject subclass: #IB isInterface: true behavesLike: { A } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'Can not behave like a non-interface!!')	].	self assert: (flag = true).		"Part 3"		MyObject subclass: #IAA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	MyObject subclass: #ICC isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	MyObject subclass: #IBB isInterface: true behavesLike: { ICC } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	MyObject subclass: #IDD isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.		IDD compile: 'defaultF'.		"ICC compile: 'defaultFoo	^true.'.	ICC compile: 'defaultFoo1	^11.'."		IAA compile: 'foo'.		"IBB compile: 'defaultFoo1	^1.'.	IBB compile: 'defaultFoo2	^2.'."		MyObject subclass: #Abs isInterface: false behavesLike: { IAA } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	MyObject subclass: #NonAbs isInterface: false behavesLike: { IBB } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	MyObject subclass: #NonAbsEmpty isInterface: false behavesLike: { ICC } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	MyObject subclass: #NonAbsToBeAbs isInterface: false behavesLike: { IDD } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.		flag := false.	[a := Abs new] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'Can not instantiate an Abstract class!!')	].	self assert: (flag = true).		a := NonAbs new.		self assert: (a isKindOf: NonAbs).	self assert: (a isKindOf: IBB).	self assert: (a isKindOf: ICC).		"self assert: (((a defaultFoo1) = 1) or: ((a defaultFoo1) = 11)).	self assert: ((a defaultFoo2) = 2)."		"Turns Abs to non abstract"	Abs compile: 'foo'.	a := Abs new.	self assert: (a isKindOf: Abs).	self assert: (a isKindOf: IAA).		"Turns NonAbsToBeAbs to abstract"	IDD compile: 'foo'.	flag := false.	[a := NonAbsToBeAbs new] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'Can not instantiate an Abstract class!!')	].	self assert: (flag = true).		a := NonAbsEmpty new.	self assert: (a isKindOf: NonAbsEmpty).	self assert: (a isKindOf: ICC).		"self assert: (a defaultFoo)."		MyObject subclass: #IEE isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.		IEE compile: 'foo1'.		"IEE compile: 'defaultF	^2.'."		MyObject subclass: #NonAbsTwo isInterface: false behavesLike: { IEE } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.		NonAbsTwo compile: 'foo1	^3.'.		a := NonAbsTwo new.	self assert: (a isKindOf: NonAbsTwo).	self assert: (a isKindOf: IEE).		"self assert: ((a defaultF) = 2)."		self assert: ((a foo1) = 3).		NonAbsTwo subclass: #NonAbsInheritance isInterface: false behavesLike: { } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP2'.	a := NonAbsInheritance new.	self assert: (a isKindOf: NonAbsInheritance).	self assert: (a isKindOf: NonAbsTwo).	self assert: (a isKindOf: IEE).		"self assert: ((a defaultF) = 2)."		self assert: ((a foo1) = 3).		"Clean up"	(Smalltalk hasClassNamed: #A) ifTrue: [Smalltalk removeClassNamed: #A].	(Smalltalk hasClassNamed: #B) ifTrue: [Smalltalk removeClassNamed: #B].	(Smalltalk hasClassNamed: #C) ifTrue: [Smalltalk removeClassNamed: #C].	(Smalltalk hasClassNamed: #IA) ifTrue: [Smalltalk removeClassNamed: #IA].	(Smalltalk hasClassNamed: #IB) ifTrue: [Smalltalk removeClassNamed: #IB].	(Smalltalk hasClassNamed: #D) ifTrue: [Smalltalk removeClassNamed: #D].	(Smalltalk hasClassNamed: #SA) ifTrue: [Smalltalk removeClassNamed: #SA].	(Smalltalk hasClassNamed: #SB) ifTrue: [Smalltalk removeClassNamed: #SB].	(Smalltalk hasClassNamed: #SC) ifTrue: [Smalltalk removeClassNamed: #SC].	(Smalltalk hasClassNamed: #IAA) ifTrue: [Smalltalk removeClassNamed: #IAA].	(Smalltalk hasClassNamed: #IBB) ifTrue: [Smalltalk removeClassNamed: #IBB].	(Smalltalk hasClassNamed: #ICC) ifTrue: [Smalltalk removeClassNamed: #ICC].	(Smalltalk hasClassNamed: #Abs) ifTrue: [Smalltalk removeClassNamed: #Abs].	(Smalltalk hasClassNamed: #NonAbs) ifTrue: [Smalltalk removeClassNamed: #NonAbs].	(Smalltalk hasClassNamed: #NonAbsEmpty) ifTrue: [Smalltalk removeClassNamed: #NonAbsEmpty].	(Smalltalk hasClassNamed: #NonAbsToBeAbs) ifTrue: [Smalltalk removeClassNamed: #NonAbsToBeAbs].	(Smalltalk hasClassNamed: #IDD) ifTrue: [Smalltalk removeClassNamed: #IDD].	(Smalltalk hasClassNamed: #E) ifTrue: [Smalltalk removeClassNamed: #E].	(Smalltalk hasClassNamed: #IEE) ifTrue: [Smalltalk removeClassNamed: #IEE].	(Smalltalk hasClassNamed: #NonAbsTwo) ifTrue: [Smalltalk removeClassNamed: #NonAbsTwo].	(Smalltalk hasClassNamed: #NonAbsInheritance) ifTrue: [Smalltalk removeClassNamed: #NonAbsInheritance].! !