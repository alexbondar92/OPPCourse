TestCase subclass: #Part1Test	instanceVariableNames: 'm1'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3Test'!!Part1Test methodsFor: 'assertFailTest' stamp: 'es 12/14/2018 15:47'!testAssertFailureself should: [MyObject  compile:'foo: a bar:b baz: c| var1 |var1 := a + c + (2 * b)."just a comment, nothing special"^ (var1 * var1)'where: #(Integer nil )] raise: AssertionFailure description: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.self should: [MyObject  compile:'foo: a bar:b baz: c| var1 |var1 := a + c + (2 * b)."just a comment, nothing special"^ (var1 * var1)'where: #(Integer nil Integer Integer)] raise: AssertionFailure description: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.self should: [MyObject  compile:'eyal^3'where: #(Integer nil Integer Integer)] raise: AssertionFailure description: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.MyObject  compile:'foo: a bar:b baz: c| var1 |var1 := a + c + (2 * b)."just a comment, nothing special"^ (var1 * var1)'where: #(Integer nil Integer).self should: [m1  foo: 'eyal' bar: 5 baz:5 ] raise: AssertionFailure description: 'Type mismatch!! Argument 1 should be Integer'.self should: [m1  foo: 'eyal' bar: 5 baz:5.0 ] raise: AssertionFailure description: 'Type mismatch!! Argument 3 should be Integer'.self assert: ((m1 foo:5 bar:5 baz: 5) == 400).MyObject  compile:'eyal^3'where: #().self assert: (m1 eyal == 3).MyObject  compile:'foo: a bar:b baz: c| var1 | ' where: #(Integer nil Integer).self should: [m1  foo: 'eyal' bar: 5 baz:5 ] raise: AssertionFailure description: 'Type mismatch!! Argument 1 should be Integer'.self assert: ((m1 foo:5 bar:5 baz: 5) == m1).MyObject  compile:'foo: a bar:b baz: c| var1 | 'where: #(Integer nil Number).self should: [m1  foo: 'eyal' bar: 5 baz:5 ] raise: AssertionFailure description: 'Type mismatch!! Argument 1 should be Integer'.self assert: ((m1 foo:5 bar:5 baz: 5) == m1)."should raise"self should: [MyObject  compile:'foo: a bar:b baz: c| var1 | 'where: #(Integer nil )] raise: AssertionFailure description: 'Can not compile method, number of arguments is not equal to the number of constraints!!'."should raise"self should: [MyObject  compile:'foo: a bar:b baz: c'where: #(Integer nil )] raise: AssertionFailure description: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.MyObject  compile:'foo: a bar:b baz: c'where: #(Integer nil Number).self should: [m1  foo: 'eyal' bar: 5 baz:5 ] raise: AssertionFailure description: 'Type mismatch!! Argument 1 should be Integer'.self assert: ((m1 foo:5 bar:5 baz: 5) == m1).MyObject removeSelector: #eyal.MyObject removeSelector: #foo:bar:baz:.! !!Part1Test methodsFor: 'initialize-release' stamp: 'es 12/14/2018 15:32'!setUp	m1:= MyObject new.! !TestCase subclass: #Part2Test	instanceVariableNames: 'm1'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3Test'!!Part2Test methodsFor: 'overrideTest' stamp: 'es 12/14/2018 15:44'!testCompileMyObject subclass: #I1 isInterface: true behavesLike: #() instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #M1 isInterface: false behavesLike: #() instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.self should: [I1  compile:'foo: a bar:b baz: c| var1 |var1 := a + c + (2 * b)."just a comment, nothing special"^ (var1 * var1)'where: #(Integer nil )] raise: AssertionFailure description: 'Interfaces are not allowed to have methods that define behavior!!'.self should: [I1  compile:'foo: a bar:b baz: c| var1 |var1 := a + c + (2 * b)."just a comment, nothing special"^ (var1 * var1)'] raise: AssertionFailure description: 'Interfaces are not allowed to have methods that define behavior!!'.M1  compile:'foo: a bar:b baz: c| var1 |var1 := a + c + (2 * b)."just a comment, nothing special"^ (var1 * var1)'where: #(Integer nil Number).m1:= M1 new.self should: [m1  foo: 'eyal' bar: 5 baz:5 ] raise: AssertionFailure description: 'Type mismatch!! Argument 1 should be Integer'.self assert: ((m1 foo:5 bar:5 baz: 5) == 400).! !!Part2Test methodsFor: 'subclassTest' stamp: 'es 12/14/2018 14:20'!testAmbiguitiesMyObject subclass: #I1 isInterface: true behavesLike: #() instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #I2 isInterface: true behavesLike:  {} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #M1 isInterface: false behavesLike:  {I1. I2} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #I3 isInterface: true behavesLike:  {I2. I1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #M2 isInterface: false behavesLike:  {I1. I3} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.M2 subclass: #M3 isInterface: false behavesLike:  {} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.I1 compile: 'f5'.self assert: ((M1 ambiguities) =  (#() asSortedCollection)).self assert: ((I1 ambiguities) size = 0).self assert: ((M2 ambiguities) =  (#(#f5) asSortedCollection)).self assert: ((M3 ambiguities) =  (#(#f5) asSortedCollection)).self assert: ((I3 ambiguities) =  (#(#f5) asSortedCollection)).I2 compile:'f5'.self assert: ((M1 ambiguities) =  (#(#f5) asSortedCollection)).I1 compile: 'f3'.self assert: ((I3 ambiguities) =  (#(#f5 #f3) asSortedCollection)).self assert: ((M2 ambiguities) =  (#(#f5 #f3) asSortedCollection)).self assert: ((M3 ambiguities) =  (#(#f5 #f3) asSortedCollection)).! !!Part2Test methodsFor: 'subclassTest' stamp: 'es 12/14/2018 16:42'!testInterfaceHierarchyMyObject subclass: #I1 isInterface: true behavesLike: {} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #I2 isInterface: true behavesLike:  {} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #M1 isInterface: false behavesLike:  {I1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #I3 isInterface: true behavesLike:  {I2. I1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #I4 isInterface: true behavesLike:  {I1. I3} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #M2 instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.M1 subclass: #M3 instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #I5 isInterface: true behavesLike:  {I1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.M3 subclass: #M4 isInterface: false behavesLike:  {I5} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.self should: [M1 isImplemented] raise: AssertionFailure description: 'M1 is not an interface!!'.self assert: ((I1 isImplemented) = true).I1 compile: 'f1'.self assert: ((I1 isImplemented) = false).self assert: ((I3 isImplemented) = false).M3 compile: 'f1'.self assert: ((I1 isImplemented) = true).self assert: ((I2 isImplemented) = false).self assert: ((I3 isImplemented) = false).self assert: ((I5 isImplemented) = true).I2 compile: 'f2'.self assert: ((I1 isImplemented) = true).self assert: ((I2 isImplemented) = false).self assert: ((I3 isImplemented) = false).! !!Part2Test methodsFor: 'subclassTest' stamp: 'es 12/14/2018 14:11'!testSubclass| sI1 sI2 sI3 sI4 sI5 sM1 sM2 sM3 sM4|sI1:= Set new.self should: [MyObject subclass: #I1 isInterface: true behavesLike: #() instanceVariableNames: #('a')classVariableNames: #() poolDictionaries: #()category: 'OOP3'] raise: AssertionFailure description: 'Interfaces can not have state!!'.MyObject subclass: #I1 isInterface: true behavesLike: #() instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.sI1 add: I1.self assert: (I1 isInterface == true).self assert: ((I1 behavesLike) = sI1).self should: [I1 subclass: #I2 isInterface: true behavesLike:  {I1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'] raise: AssertionFailure description: 'Interfaces must derive from MyObject!!'.MyObject subclass: #I2 isInterface: true behavesLike:  {I1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.self assert: (I2 isInterface == true).sI2:= sI1 deepCopy.sI2 add: I2.self assert: ((I2 behavesLike) = sI2).MyObject subclass: #M1 isInterface: false behavesLike:  {I1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.sM1:= sI1 deepCopy.self assert: (M1 isInterface == false).self assert: ((M1 behavesLike) = sM1).self should: [MyObject subclass: #I3 isInterface: false behavesLike:  {I1. M1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'] raise: AssertionFailure description:'Can not behave like a non-interface!!'.self should: [M1 subclass: #I3 isInterface: true behavesLike:  {I1. M1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'] raise: AssertionFailure description:'Interfaces must derive from MyObject!!'.MyObject subclass: #I3 isInterface: true behavesLike:  {I2. I1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.sI3:= sI2 deepCopy.sI3 add: I3.self assert: (I3 isInterface == true).self assert: ((I3 behavesLike) = sI3).MyObject subclass: #I4 isInterface: true behavesLike:  {I1. I3} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.sI4:= sI3 deepCopy.sI4 add: I4.self assert: (I4 isInterface == true).self assert: ((I4 behavesLike) = sI4).MyObject subclass: #M2 instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.sM2:= Set new.self assert: (M2 isInterface == false).self assert: ((M2 behavesLike) = sM2).M1 subclass: #M3 instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.sM3:= sM1 deepCopy.self assert: (M3 isInterface == false).self assert: ((M3 behavesLike) = sM3).MyObject subclass: #I5 isInterface: true behavesLike:  {} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.sI5:= Set new.sI5 add: I5.self assert: (I5 isInterface == true).self assert: ((I5 behavesLike) = sI5).M3 subclass: #M4 isInterface: false behavesLike:  {I5} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.sM4:= sM3 deepCopy.sM4 addAll: sI5.self assert: (M4 isInterface == false).self assert: ((M4 behavesLike) = sM4).! !!Part2Test methodsFor: 'initialize-release' stamp: 'D.g 12/11/2018 19:22'!setUpMyObject instVarNamed: 'isInterface' put: false.MyObject instVarNamed: 'behavesLike' put: {}.(Smalltalk hasClassNamed: #I5) ifTrue: [Smalltalk removeClassNamed: #I5].(Smalltalk hasClassNamed: #I4) ifTrue: [Smalltalk removeClassNamed: #I4].(Smalltalk hasClassNamed: #I3) ifTrue: [Smalltalk removeClassNamed: #I3].(Smalltalk hasClassNamed: #I2) ifTrue: [Smalltalk removeClassNamed: #I2].(Smalltalk hasClassNamed: #I1) ifTrue: [Smalltalk removeClassNamed: #I1].(Smalltalk hasClassNamed: #M4) ifTrue: [Smalltalk removeClassNamed: #M4].(Smalltalk hasClassNamed: #M3) ifTrue: [Smalltalk removeClassNamed: #M3].(Smalltalk hasClassNamed: #M2) ifTrue: [Smalltalk removeClassNamed: #M2].(Smalltalk hasClassNamed: #M1) ifTrue: [Smalltalk removeClassNamed: #M1].! !TestCase subclass: #Part3Test	instanceVariableNames: 'm1 m2 m3 m4 f5 f1 f2 f3 f4'	classVariableNames: 'Argument M5'	poolDictionaries: ''	category: 'OOP3Test'!!Part3Test methodsFor: 'initialize-release' stamp: 'es 12/15/2018 20:18'!setUpMyObject instVarNamed: 'isInterface' put: false.MyObject instVarNamed: 'behavesLike' put: {}.(Smalltalk hasClassNamed: #I5) ifTrue: [Smalltalk removeClassNamed: #I5].(Smalltalk hasClassNamed: #I4) ifTrue: [Smalltalk removeClassNamed: #I4].(Smalltalk hasClassNamed: #I3) ifTrue: [Smalltalk removeClassNamed: #I3].(Smalltalk hasClassNamed: #I2) ifTrue: [Smalltalk removeClassNamed: #I2].(Smalltalk hasClassNamed: #I1) ifTrue: [Smalltalk removeClassNamed: #I1].(Smalltalk hasClassNamed: #M6) ifTrue: [Smalltalk removeClassNamed: #M6].(Smalltalk hasClassNamed: #M4) ifTrue: [Smalltalk removeClassNamed: #M4].(Smalltalk hasClassNamed: #M3) ifTrue: [Smalltalk removeClassNamed: #M3].(Smalltalk hasClassNamed: #M2) ifTrue: [Smalltalk removeClassNamed: #M2].(Smalltalk hasClassNamed: #M1) ifTrue: [Smalltalk removeClassNamed: #M1].! !!Part3Test methodsFor: 'IsKindOfTest' stamp: 'es 12/14/2018 16:01'!testIsKindOfMyObject subclass: #I1 isInterface: true behavesLike: #() instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #I2 isInterface: true behavesLike:  {} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #M1 isInterface: false behavesLike:  {I1. I2} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #I3 isInterface: true behavesLike:  {I2. I1} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #M2 isInterface: false behavesLike:  {I3} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.M2 subclass: #M3 isInterface: false behavesLike:  {} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.MyObject subclass: #M4 isInterface: false behavesLike:  {} instanceVariableNames: ''classVariableNames: '' poolDictionaries: ''category: 'OOP3'.m1:= M1 new.self assert: ((m1 isKindOf: M1) = true).self assert:  ((m1 isKindOf: MyObject) = true).self assert:  ((m1 isKindOf: I1) = true).self assert:  ((m1 isKindOf: I2) = true).m2:= M2 new.self assert: ((m2 isKindOf: M2) = true).self assert:  ((m2 isKindOf: MyObject) = true).self assert:  ((m2 isKindOf: I1) = true).self assert:  ((m2 isKindOf: I2) = true).self assert:  ((m2 isKindOf: I3) = true).m3:= M3 new.self assert: ((m3 isKindOf: M3) = true).self assert: ((m3 isKindOf: M2) = true).self assert:  ((m3 isKindOf: MyObject) = true).self assert:  ((m3 isKindOf: I1) = true).self assert:  ((m3 isKindOf: I2) = true).self assert:  ((m3 isKindOf: I3) = true).m4:= M4 new.self assert: ((m4 isKindOf: M4) = true).self assert:  ((m4 isKindOf: MyObject) = true).self assert:  ((m4 isKindOf: I1) = false).self assert:  ((m4 isKindOf: I2) = false).self assert:  ((m4 isKindOf: I3) = false).! !!Part3Test methodsFor: 'newTest' stamp: 'es 12/15/2018 20:18'!testNew|flag a b|MyObject subclass: #I1 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	MyObject subclass: #I2 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	MyObject subclass: #I3 isInterface: true behavesLike: { I2 } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	MyObject subclass: #I4 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.		I4 compile: 'f4'.	I2 compile: 'f3'.	I2 compile: 'f1'.	I1 compile: 'foo'.	I3 compile: 'f5'.	I3 compile: 'f2'.		MyObject subclass: #M1 isInterface: false behavesLike: { I1 } instanceVariableNames: '' classVariableNames: '' 	poolDictionaries: '' category: 'OOP3'.		MyObject subclass: #M2 isInterface: false behavesLike: { I3 } instanceVariableNames: '' classVariableNames: '' 	poolDictionaries: '' category: 'OOP3'.			MyObject subclass: #M4 isInterface: false behavesLike: { I4 } instanceVariableNames: '' classVariableNames: '' 	poolDictionaries: '' category: 'OOP3'.		M4 subclass: #M3 isInterface: false behavesLike: { I2 } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	flag := false.	[a := M1 new] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'Can not instantiate an Abstract class!!')	].	self assert: (flag = true).		M2 compile: 'f1	^1.'.	M2 compile: 'f2	^2.'.	M2 compile: 'f3	^3.'.	M2 compile: 'f5	^5.'.	a := M2 new.		self assert: (a isKindOf: M2).	self assert: (a isKindOf: I3).	self assert: (a isKindOf: I2).		self assert: ((a f5) = 5).	self assert:((a f1) = 1).	self assert: ((a f2) = 2).	self assert: ((a f3) = 3).		"Turns M1 to non abstract"	M1 compile: 'foo'.	a := M1 new.	self assert: (a isKindOf: M1).	self assert: (a isKindOf: I1).	M4 compile: 'f4	^4.'.	(I4 includesSelector: #fu) ifTrue: [I4 removeSelector: #fu].	a := M4 new.		self assert: (a isKindOf: M4).	self assert: (a isKindOf: I4).		self assert: ( (a  f4) = 4).	"Turns M4 to abstract"	I4 compile: 'fu'.	flag := false.	[a := M4 new] on: AssertionFailure do: 	[ :e |		flag := true.		self assert: (e messageText = 'Can not instantiate an Abstract class!!')	].	self assert: (flag = true).		"M3 inherits from an Abstract M4"	M3 compile: 'f1	^11.'.	M3 compile: 'f3	^3.'.	M3 compile: 'f4	^4.'.	M3 compile: 'fu	^true.'.	a := M3 new.	self assert: (a isKindOf: M3).	self assert: (a isKindOf: M4).	self assert: (a isKindOf: I2).	self assert: (a isKindOf: I4).	self assert: ((a f3) = 3).		"M5 inherits from nonAbstract M1"	M1 subclass: #M6 isInterface: false behavesLike: { I4 } instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.self assert: (M6 superclass = M1).self should: [b := M6 new] raise: AssertionFailure description: 'Can not instantiate an Abstract class!!'.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Part3Test class	instanceVariableNames: 'a flag b'!