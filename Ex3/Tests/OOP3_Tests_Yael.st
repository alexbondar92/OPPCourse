TestCase subclass: #OOP3Tests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3_Tests_Yael'!!OOP3Tests methodsFor: 'Part1' stamp: 'Yael 12/22/2018 19:34'!testCompileWhere| message a |MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.self assert: (A methodDict isEmpty)."number of arguments doesn't equal number of elements in anOrderedCollection"message := 'Can not compile method, number of arguments is not equal to the number of constraints!!'.self expectErrorFrom: [ A compile: 'foo: a' where: #() ] withErrMessage: message.self expectErrorFrom: [ A compile: 'foo: a' where: #(Integer nil) ] withErrMessage: message.self expectErrorFrom: [ A compile: 'foo' where: #(nil) ] withErrMessage: message.self expectErrorFrom: [ A compile: 'foo: a bar: b' where: #(Integer) ] withErrMessage: message.self assert: (A methodDict isEmpty).   "Error cases shouldn't add methods""compile different methods, you should also check in the browser that the methods are created as expected"a := A new.A compile: 'foo^42.' where: #().self assert: (A methodDict size = 1).self assert: ((a foo) = 42).A compile: 'foo1: a^a.' where: #(Integer).self assert: (A methodDict size = 2).self assert: ((a foo1: 42) = 42).self expectErrorFrom: [ a foo1: 4.2 ] withErrMessage: 'Type mismatch!! Argument 1 should be Integer'.A compile:'foo2:a^a.'where: #(Integer).self assert: (A methodDict size = 3).self assert: ((a foo2: 42) = 42).self expectErrorFrom: [ a foo2: 4.2 ] withErrMessage: 'Type mismatch!! Argument 1 should be Integer'.A compile:'foo: a bar: b^(a+b).'where: #(nil Integer).self assert: (A methodDict size = 4).self assert: ((a foo: 42 bar: 42) = 84).self assert: ((a foo: 42.1 bar: 42) = 84.1).self expectErrorFrom: [ a foo: 42 bar: 4.2] withErrMessage: 'Type mismatch!! Argument 2 should be Integer'.A compile:'foo1:a bar1:b| result |result := a + b.^result.'where: #(Integer nil).self assert: (A methodDict size = 5).self assert: ((a foo1: 42 bar1: 42) = 84).self assert: ((a foo1: 42 bar1: 42.1) = 84.1).A compile:'foo: a bar:b baz: c| var1 |var1 := 2 * a + b."just a comment"^var1.'where: #(Integer Number String).self assert: (A methodDict size = 6).self assert: ((a foo: 21 bar: 42 baz: 'Hello') = 84).self expectErrorFrom: [ a foo: 4.2 bar: 42 baz: 'Hello'] withErrMessage: 'Type mismatch!! Argument 1 should be Integer'.self expectErrorFrom: [ a foo: 42 bar: 'OK' baz: 'Hello'] withErrMessage: 'Type mismatch!! Argument 2 should be Number'.self expectErrorFrom: [ a foo: 42 bar: 4.2 baz: 5] withErrMessage: 'Type mismatch!! Argument 3 should be String'.self expectErrorFrom: [ a foo: 4.2 bar: 42 baz: 5] withErrMessage: 'Type mismatch!! Argument 1 should be Integer'.self expectErrorFrom: [ a foo: 42 bar: 'OK' baz: 5] withErrMessage: 'Type mismatch!! Argument 2 should be Number'.! !!OOP3Tests methodsFor: 'Part2' stamp: 'Yael 12/23/2018 19:29'!testAmbiguities| ambs |MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #IB isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #A isInterface: false behavesLike: {IA. IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'."no ambiguities"self assert: (A ambiguities size = 0).IA compile: 'foo'.self assert: (A ambiguities size = 0).IB compile: 'foo: a'.self assert: (A ambiguities size = 0)."a class behaves like 2 unrelated interfaces, and both interfaces define the same method"IB compile: 'foo'.ambs := A ambiguities.self assert: ((ambs size = 1) and: [(ambs at: 1) = #foo])."interface behaves like another interface - causes ambiguities"MyObject subclass: #IC isInterface: true behavesLike: {IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.ambs := IC ambiguities.self assert: ((ambs size = 2) and: [(ambs at: 1) = #foo] and: [(ambs at: 2) = #foo:]).MyObject subclass: #B isInterface: false behavesLike: {IC} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.ambs := B ambiguities.self assert: ((ambs size = 2) and: [(ambs at: 1) = #foo] and: [(ambs at: 2) = #foo:])."some more tests"IA compile: 'bar: b'.IB compile: 'bar'.ambs := A ambiguities.self assert: ((ambs size = 1) and: [(ambs at: 1) = #foo]).ambs := IC ambiguities.self assert: ((ambs size = 3) and: [(ambs at: 1) = #bar] and: [(ambs at: 2) = #foo] and: [(ambs at: 3) = #foo:]).ambs := B ambiguities.self assert: ((ambs size = 3) and: [(ambs at: 1) = #bar] and: [(ambs at: 2) = #foo] and: [(ambs at: 3) = #foo:]).MyObject subclass: #ID isInterface: true behavesLike: {IA. IC} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.ambs := ID ambiguities.self assert: ((ambs size = 4) and: [(ambs at: 1) = #bar] and: [(ambs at: 2) = #bar:] and: [(ambs at: 3) = #foo] and: [(ambs at: 4) = #foo:]).ID compile: 'baz'.ambs := ID ambiguities.self assert: ((ambs size = 4) and: [(ambs at: 1) = #bar] and: [(ambs at: 2) = #bar:] and: [(ambs at: 3) = #foo] and: [(ambs at: 4) = #foo:]).B subclass: #C isInterface: false behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.IA compile: 'baz'.ambs := C ambiguities.self assert: ((ambs size = 3) and: [(ambs at: 1) = #bar] and: [(ambs at: 2) = #foo] and: [(ambs at: 3) = #foo:]).IA compile: 'a'.IA compile: 'foo: a baz: c'.IC compile: 'a'.IC compile: 'foo: a baz: c'.ambs := C ambiguities.self assert: ((ambs size = 5)).self assert: (((ambs at: 1) = #a) and: [(ambs at: 2) = #bar] and: [(ambs at: 3) = #foo] and: [(ambs at: 4) = #foo:] and: [(ambs at: 5) = #foo:baz:])."test print order"Transcript show: (C ambiguities). "check print on Transcript window, should get this text: a SortedCollection(#a #bar #foo #foo: #foo:baz:)"! !!OOP3Tests methodsFor: 'Part2' stamp: 'Yael 12/23/2018 18:53'!testBehavesLike| behaves |self assert: (MyObject behavesLike size = 0).MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #IB isInterface: true behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #IC isInterface: true behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #ID isInterface: true behavesLike: {IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #IE isInterface: true behavesLike: {ID. IC} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #IF isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #A isInterface: false behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.A subclass: #B isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.A subclass: #B2 instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #C isInterface: false behavesLike: {IE} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.B subclass: #D isInterface: false behavesLike: {IF} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.B2 subclass: #D2 isInterface: false behavesLike: {IF} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.C subclass: #E instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #F instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #F2 isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.self assert: (IA behavesLike size = 1).self assert: (IA behavesLike includes: IA).behaves := IB behavesLike.self assert: (behaves size = 2).self assert: ((behaves includes: IA) and: [behaves includes: IB]).behaves := IC behavesLike.self assert: (behaves size = 2).self assert: ((behaves includes: IA) and: [behaves includes: IC]).behaves := ID behavesLike.self assert: (behaves size = 3).self assert: ((behaves includes: IA) and: [behaves includes: IB] and: [behaves includes: ID]).behaves := IE behavesLike.self assert: (behaves size = 5).self assert: ((behaves includes: IA) and: [behaves includes: IB] and: [behaves includes: ID] and: [behaves includes: IC] and: [behaves includes: IE]).behaves := IF behavesLike.self assert: (behaves size = 1).self assert: (behaves includes: IF).self assert: (A behavesLike size =  1).self assert: (A behavesLike includes: IA).self assert: (B behavesLike size =  1).self assert: (B behavesLike includes: IA).self assert: (B2 behavesLike size =  1).self assert: (B2 behavesLike includes: IA).behaves := C behavesLike.self assert: (behaves size = 5).self assert: ((behaves includes: IA) and: [behaves includes: IB] and: [behaves includes: ID] and: [behaves includes: IC] and: [behaves includes: IE]).behaves := D behavesLike.self assert: (behaves size =  2).self assert: ((behaves includes: IA) and: [behaves includes: IF]).behaves := D2 behavesLike.self assert: (behaves size =  2).self assert: ((behaves includes: IA) and: [behaves includes: IF]).behaves := E behavesLike.self assert: (behaves size = 5).self assert: ((behaves includes: IA) and: [behaves includes: IB] and: [behaves includes: ID] and: [behaves includes: IC] and: [behaves includes: IE]).self assert: (F behavesLike size = 0).self assert: (F2 behavesLike size = 0).! !!OOP3Tests methodsFor: 'Part2' stamp: 'Yael 12/23/2018 20:03'!testCompileMyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'."try to compile an interface method with implementation"self expectErrorFrom: [ IA compile: 'foo: a	^42.' ] withErrMessage: 'Interfaces are not allowed to have methods that define behavior!!'.self expectErrorFrom: [ IA compile: 'foo	| temp |' ] withErrMessage: 'Interfaces are not allowed to have methods that define behavior!!'."compile interface method without implementation - should not raise any error"IA compile: 'foo'.IA compile: 'foo: a'.self assert: (IA methodDict size = 2)."compile regular class method - should not raise any error"MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.A compile: 'bar'.A compile: 'foo: a^42.'.A compile: 'foo| temp |'.self assert: (A methodDict size = 3).! !!OOP3Tests methodsFor: 'Part2' stamp: 'Yael 12/23/2018 18:17'!testIsImplemented"check the empty case, interface and class has no methods"MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #A isInterface: false behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.self assert: (IA isImplemented = true). "IA implemented by A, because A behaves like IA and IA has no methods""trying to call method on a regular class"self expectErrorFrom: [ A isImplemented ] withErrMessage: 'A is not an interface!!'."an interface can only be implemented by a class that behaves like the interface"MyObject subclass: #IB isInterface: true behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.self assert: (IB isImplemented = false). "there are no subclasses of MyObject that behave like IB""interface has methods that the class doesn't have"IA compile: 'foo: a'.self assert: (IA isImplemented = false).A compile: 'foo^42.'.self assert: (IA isImplemented = false).A compile:'foo:a^a.'.self assert: (IA isImplemented = true). "now its ok""implements method by inheritance"IA compile: 'bar: b'.self assert: (IA isImplemented = false).A subclass: #B instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.B compile:'bar: b^(2 * b).'where: #(Integer).self assert: (IA isImplemented = true). "B behaves like IA by inheritance. B implements method 'bar: b' by himself, and implements 'foo: a' by inheritance from A."B subclass: #C isInterface: false behavesLike: {IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.self assert: (IB isImplemented = true). "C behaves like IB, and it knows both 'foo: a' and 'bar: b' by inheritance. IB only has IA's methods.""interface cannot implement another interface"MyObject subclass: #IC isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #ID isInterface: true behavesLike: {IC} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.self assert: (IC isImplemented = false).! !!OOP3Tests methodsFor: 'Part2' stamp: 'Yael 12/23/2018 19:40'!testNewInterface| obj |MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'."try to create an instance of an interface"self expectErrorFrom: [ IA new ] withErrMessage: 'Interfaces can not be instantiated!!'."trying to create instances of a regular class should work fine"obj := MyObject new.self assert: ( obj isMemberOf: MyObject ).MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.A subclass: #B isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.obj := A new.self assert: ( obj isMemberOf: A ).obj := B new.self assert: ( obj isMemberOf: B ).! !!OOP3Tests methodsFor: 'Part2' stamp: 'Yael 12/23/2018 11:13'!testSubclassInterface| newClass |"create subclasses and interfaces successfully"newClass := MyObject subclass: #A isInterface: false behavesLike: {} instanceVariableNames: 'var' classVariableNames: '' poolDictionaries: '' category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (A class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: A)."Check fields:"self assert: (A isInterface = false).self assert: (A behavesLike size = 0).newClass := A subclass: #B isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: 'Var' poolDictionaries: '' category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (B class)). "Check inheritance correctness:"self assert: (newClass superclass = A).self assert: ((A subclasses) includes: B)."Check fields:"self assert: (B isInterface = false).self assert: (B behavesLike size = 0).newClass := MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (IA class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: IA)."Check fields:"self assert: (IA isInterface = true).self assert: (IA behavesLike size = 1). "interface always behaves like himself"newClass := MyObject subclass: #C isInterface: false behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (C class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: C)."Check fields:"self assert: (C isInterface = false).self assert: (C behavesLike size = 1).newClass := MyObject subclass: #IB isInterface: true behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (IB class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: IB)."Check fields:"self assert: (IB isInterface = true).self assert: (IB behavesLike size = 2)."trying to create an interface that doesn't inherites directly from MyObject"self expectErrorFrom: [ A subclass: #IAA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. ] 	withErrMessage: 'Interfaces must derive from MyObject!!'.self expectErrorFrom: [ IA subclass: #IAA2 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. ] 	withErrMessage: 'Interfaces must derive from MyObject!!'."trying to create an interface with state"self expectErrorFrom: [ MyObject subclass: #IC isInterface: true behavesLike: {} instanceVariableNames: 'var' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. ] 	withErrMessage: 'Interfaces can not have state!!'."trying to create a regular class that inherites from an interface"self expectErrorFrom: [ IA subclass: #D isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. ] 	withErrMessage: 'Classes can not derive from an interface!!'.	"behavesLike contains non-interfaces"self expectErrorFrom: [ MyObject subclass: #ID isInterface: true behavesLike: {IA. A} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. ] 	withErrMessage: 'Can not behave like a non-interface!!'.self expectErrorFrom: [ B subclass: #E isInterface: false behavesLike: {IA. A} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. ] 	withErrMessage: 'Can not behave like a non-interface!!'.	"check error order when multiple errors occure"self expectErrorFrom: [ A subclass: #IE isInterface: true behavesLike: {IA. A} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. ] 	withErrMessage: 'Interfaces must derive from MyObject!!'.self expectErrorFrom: [ MyObject subclass: #IE2 isInterface: true behavesLike: {IA. A} instanceVariableNames: 'var' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. ] 	withErrMessage: 'Interfaces can not have state!!'.	self expectErrorFrom: [ IA subclass: #F isInterface: false behavesLike: {IA. A} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. ] 	withErrMessage: 'Classes can not derive from an interface!!'."check the subclasses were not created when error occured"self assert: ( ( Smalltalk hasClassNamed: #D ) = false ).self assert: ( ( Smalltalk hasClassNamed: #E ) = false ).self assert: ( ( Smalltalk hasClassNamed: #F ) = false ).self assert: ( ( Smalltalk hasClassNamed: #IAA ) = false ).self assert: ( ( Smalltalk hasClassNamed: #IAA2 ) = false ).self assert: ( ( Smalltalk hasClassNamed: #IC ) = false ).self assert: ( ( Smalltalk hasClassNamed: #ID ) = false ).self assert: ( ( Smalltalk hasClassNamed: #IE ) = false ).self assert: ( ( Smalltalk hasClassNamed: #IE2 ) = false ).! !!OOP3Tests methodsFor: 'Part2' stamp: 'Yael 12/23/2018 10:22'!testSubclassRegular| newClass |"create subclasses successfully"newClass := MyObject subclass: #A instanceVariableNames: 'var' classVariableNames: '' poolDictionaries: '' category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (A class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: A)."Check fields:"self assert: (A isInterface = false).self assert: (A behavesLike size = 0).newClass := A subclass: #B instanceVariableNames: '' classVariableNames: 'Var' poolDictionaries: '' category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (B class)). "Check inheritance correctness:"self assert: (newClass superclass = A).self assert: ((A subclasses) includes: B)."Check fields:"self assert: (B isInterface = false).self assert: (B behavesLike size = 0)."trying to create a regular class that inherites from an interface"newClass := MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.self expectErrorFrom: [ IA subclass: #C instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. ] 	withErrMessage: 'Classes can not derive from an interface!!'.	"check the subclasse was not created when error occured"self assert: ( ( Smalltalk hasClassNamed: #C ) = false ).! !!OOP3Tests methodsFor: 'Part3' stamp: 'Yael 12/23/2018 20:47'!testIsKindOf| obj |MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #IB isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #IC isInterface: true behavesLike: {IA. IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #A isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.A subclass: #B isInterface: false behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.A subclass: #C isInterface: false behavesLike: {IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #D isInterface: false behavesLike: {IC} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.obj := MyObject new.self assert: (obj isKindOf: MyObject).self assert: (((obj isKindOf: IA) = false) and: [(obj isKindOf: IB) = false] and: [(obj isKindOf: IC) = false]).obj := A new.self assert: ((obj isKindOf: MyObject) and: [obj isKindOf: A]).self assert: (((obj isKindOf: IA) = false) and: [(obj isKindOf: IB) = false] and: [(obj isKindOf: IC) = false]).obj := B new.self assert: ((obj isKindOf: MyObject) and: [obj isKindOf: A] and: [obj isKindOf: B] and: [obj isKindOf: IA]).self assert: (((obj isKindOf: IB) = false) and: [(obj isKindOf: IC) = false]).obj := C new.self assert: ((obj isKindOf: MyObject) and: [obj isKindOf: A] and: [obj isKindOf: C] and: [obj isKindOf: IB]).self assert: (((obj isKindOf: IA) = false) and: [(obj isKindOf: IC) = false]).obj := D new.self assert: ((obj isKindOf: MyObject) and: [obj isKindOf: D]).self assert: (((obj isKindOf: IA)) and: [(obj isKindOf: IB)] and: [(obj isKindOf: IC)]).self assert: (((obj isKindOf: A) = false) and: [(obj isKindOf: B) = false] and: [(obj isKindOf: C) = false]).! !!OOP3Tests methodsFor: 'Part3' stamp: 'Yael 12/23/2018 20:18'!testNewAbstractMyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #IB isInterface: true behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #A isInterface: false behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.IA compile: 'foo'."can create a subclass of an abstract class"A subclass: #B instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.MyObject subclass: #C isInterface: false behavesLike: {IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'."try to create an instance of an abstract class"self expectErrorFrom: [ A new ] withErrMessage: 'Can not instantiate an Abstract class!!'.self expectErrorFrom: [ B new ] withErrMessage: 'Can not instantiate an Abstract class!!'.self expectErrorFrom: [ C new ] withErrMessage: 'Can not instantiate an Abstract class!!'."turn an abstract class into regular class - now we can create instances"B compile: 'foo^42.'.self assert: ((B new) isMemberOf: B).self expectErrorFrom: [ A new ] withErrMessage: 'Can not instantiate an Abstract class!!'."create an abstract class that inherites from a regular class"IB compile: 'bar'.B subclass: #D isInterface: false behavesLike: {IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.self expectErrorFrom: [ D new ] withErrMessage: 'Can not instantiate an Abstract class!!'.self assert: ((B new) isMemberOf: B)."turn a regular class into an abstact class"IA compile: 'bar'.self expectErrorFrom: [ B new ] withErrMessage: 'Can not instantiate an Abstract class!!'.! !!OOP3Tests methodsFor: 'unclassified' stamp: 'Yael 12/22/2018 21:26'!expectErrorFrom: aBlock withErrMessage: aMessage	self should: aBlock raise: AssertionFailure  withExceptionDo:  [:e | self assert: (e messageText = aMessage) ]. ! !!OOP3Tests methodsFor: 'setUp' stamp: 'Yael 12/23/2018 11:06'!setUpMyObject instVarNamed: 'isInterface' put: false.MyObject instVarNamed: 'behavesLike' put: {}."Remove any classes which might have remained from previous tests"(Smalltalk hasClassNamed: #A) ifTrue: [Smalltalk removeClassNamed: #A].(Smalltalk hasClassNamed: #B) ifTrue: [Smalltalk removeClassNamed: #B].(Smalltalk hasClassNamed: #B2) ifTrue: [Smalltalk removeClassNamed: #B2].(Smalltalk hasClassNamed: #C) ifTrue: [Smalltalk removeClassNamed: #C].(Smalltalk hasClassNamed: #D) ifTrue: [Smalltalk removeClassNamed: #D].(Smalltalk hasClassNamed: #D2) ifTrue: [Smalltalk removeClassNamed: #D2].(Smalltalk hasClassNamed: #E) ifTrue: [Smalltalk removeClassNamed: #E].(Smalltalk hasClassNamed: #F) ifTrue: [Smalltalk removeClassNamed: #F].(Smalltalk hasClassNamed: #F2) ifTrue: [Smalltalk removeClassNamed: #F2].(Smalltalk hasClassNamed: #IA) ifTrue: [Smalltalk removeClassNamed: #IA].(Smalltalk hasClassNamed: #IB) ifTrue: [Smalltalk removeClassNamed: #IB].(Smalltalk hasClassNamed: #IC) ifTrue: [Smalltalk removeClassNamed: #IC].(Smalltalk hasClassNamed: #ID) ifTrue: [Smalltalk removeClassNamed: #ID].(Smalltalk hasClassNamed: #IE) ifTrue: [Smalltalk removeClassNamed: #IE].(Smalltalk hasClassNamed: #IF) ifTrue: [Smalltalk removeClassNamed: #IF]."Add classes to be used in the test"! !